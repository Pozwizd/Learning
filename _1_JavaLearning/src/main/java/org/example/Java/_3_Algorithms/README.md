# Алгоритмы и структуры данных в Java - Структура примеров

Эта директория содержит организованные примеры по алгоритмам и структурам данных, соответствующие структуре файла `Алгоритмы и структуры данных в Java.md`.

## Структура директорий

### **_01_Complexity** - Анализ сложности алгоритмов
- `_01_BigOExamples.java` - Демонстрация различных типов сложности (O(1), O(log n), O(n), O(n²), O(2^n))

### **_02_Arrays** - Массивы и строки
- `_01_BinarySearch.java` - Бинарный поиск
- `_02_CaesarCipher.java` - Шифр Цезаря
- `_03_TwoPointers.java` - Техника двух указателей (палиндром, two sum, удаление дубликатов)
- `_04_SlidingWindow.java` - Скользящее окно (максимальная сумма, минимальная длина)

### **_03_LinkedLists** - Связные списки
- `_01_SinglyLinkedList.java` - Реализация односвязного списка
- `_02_FastSlowPointers.java` - Техника быстрого и медленного указателей (Floyd's Cycle Detection)

### **_04_StackQueue** - Стек и очередь
- `_01_BalancedParentheses.java` - Проверка сбалансированности скобок

### **_05_HashMap** - Хеш-таблицы
- `_01_HashMapBasics.java` - Основные операции с HashMap (частота, анаграммы, two sum, первый уникальный)

### **_06_Trees** - Деревья
- `_01_BinaryTree.java` - Бинарное дерево и обходы (DFS, BFS)

### **_07_Graphs** - Графы
- `_01_Dijkstra.java` - Алгоритм Дейкстры (кратчайший путь)

### **_08_Sorting** - Алгоритмы сортировки
- `_01_BubbleSort.java` - Пузырьковая сортировка O(n²)
- `_02_QuickSort.java` - Быстрая сортировка O(n log n)
- `_03_MergeSort.java` - Сортировка слиянием O(n log n)

### **_09_Recursion** - Рекурсия и Backtracking
- `_01_RecursionBasics.java` - Основы рекурсии (факториал, Фибоначчи, степень)
- `_02_Backtracking.java` - Возврат назад (подмножества, перестановки, N Queens)

### **_10_DynamicProgramming** - Динамическое программирование
- `_01_Fibonacci.java` - Фибоначчи с мемоизацией и табуляцией
- `_02_Knapsack.java` - Задача о рюкзаке (0/1 Knapsack)

### **_11_Greedy** - Жадные алгоритмы
- `_01_ActivitySelection.java` - Выбор максимального количества активностей
- `_02_CoinChange.java` - Размен монет (greedy vs DP)

## Соответствие разделам из Markdown

| Раздел MD | Директория | Описание |
|-----------|-----------|----------|
| §1. Анализ сложности алгоритмов | `_01_Complexity/` | Big O нотация, типы сложности |
| §2. Массивы и строки | `_02_Arrays/` | Бинарный поиск, Two Pointers, Sliding Window |
| §3. Связные списки | `_03_LinkedLists/` | Односвязный список, Fast & Slow Pointers |
| §4. Стек и очередь | `_04_StackQueue/` | Stack (LIFO), Queue (FIFO), Priority Queue |
| §5. Хеш-таблицы | `_05_HashMap/` | HashMap операции, паттерны использования |
| §6. Деревья | `_06_Trees/` | Бинарное дерево, BST, обходы |
| §7. Графы | `_07_Graphs/` | Представление графов, DFS, BFS, Dijkstra |
| §8. Алгоритмы сортировки | `_08_Sorting/` | Bubble, Quick, Merge Sort |
| §9. Рекурсия и Backtracking | `_09_Recursion/` | Рекурсивные алгоритмы, возврат назад |
| §10. Динамическое программирование | `_10_DynamicProgramming/` | Мемоизация, табуляция, оптимизация |
| §11. Жадные алгоритмы | `_11_Greedy/` | Локально оптимальный выбор |

## Сложность алгоритмов - шпаргалка

### Временная сложность

| Обозначение | Название | Пример | Производительность |
|-------------|----------|--------|-------------------|
| O(1) | Константная | Доступ к элементу массива | ⚡ Отлично |
| O(log n) | Логарифмическая | Бинарный поиск | ✅ Очень хорошо |
| O(n) | Линейная | Проход по массиву | ✅ Хорошо |
| O(n log n) | Линейно-логарифмическая | Merge Sort, Quick Sort | ✅ Хорошо |
| O(n²) | Квадратичная | Bubble Sort, вложенные циклы | ⚠️ Приемлемо для малых данных |
| O(2^n) | Экспоненциальная | Наивный Фибоначчи | ❌ Плохо |
| O(n!) | Факториальная | Перебор всех перестановок | ❌ Очень плохо |

### Операции со структурами данных

| Структура | Доступ | Поиск | Вставка | Удаление |
|-----------|--------|-------|---------|----------|
| Array | O(1) | O(n) | O(n) | O(n) |
| Linked List | O(n) | O(n) | O(1)* | O(1)* |
| Stack | O(n) | O(n) | O(1) | O(1) |
| Queue | O(n) | O(n) | O(1) | O(1) |
| HashMap | - | O(1)** | O(1)** | O(1)** |
| Binary Search Tree | O(log n)** | O(log n)** | O(log n)** | O(log n)** |
| Heap | - | O(n) | O(log n) | O(log n) |

\* - если известна позиция  
\*\* - средний случай

## Как использовать

### 1. Последовательное изучение
```
_01_Complexity → _02_Arrays → _03_LinkedLists → ... → _11_Greedy
```

### 2. Запуск примеров
Каждый файл содержит метод `main()`:
```bash
cd _01_Complexity
javac -encoding UTF-8 _01_BigOExamples.java
java org.example.Java._3_Algorithms._01_Complexity._01_BigOExamples
```

### 3. Практика решения задач

#### Начальный уровень:
- Массивы: бинарный поиск, two pointers
- Хеш-таблицы: подсчет частоты, анаграммы
- Рекурсия: факториал, Фибоначчи

#### Средний уровень:
- Связные списки: разворот, поиск цикла
- Деревья: обходы, поиск
- Сортировки: Quick Sort, Merge Sort

#### Продвинутый уровень:
- Графы: DFS, BFS, Dijkstra
- Динамическое программирование: рюкзак, подпоследовательности
- Backtracking: N Queens, комбинаторика

## Полезные ресурсы

### Онлайн-практика
- [LeetCode](https://leetcode.com/) - 2000+ задач
- [HackerRank](https://www.hackerrank.com/) - задачи с пошаговым решением
- [Codeforces](https://codeforces.com/) - соревновательное программирование

### Книги
- "Cracking the Coding Interview" - Gayle Laakmann McDowell
- "Introduction to Algorithms" (CLRS) - классический учебник
- "Algorithms" - Robert Sedgewick

### Визуализация
- [VisuAlgo](https://visualgo.net/) - визуализация алгоритмов
- [Algorithm Visualizer](https://algorithm-visualizer.org/)

## Паттерны решения задач

### Two Pointers
- Используйте для отсортированных массивов
- Один указатель идет с начала, другой с конца
- Применение: палиндромы, two sum, удаление дубликатов

### Sliding Window
- Для задач на подмассивы/подстроки
- Поддерживайте окно фиксированного или переменного размера
- Применение: максимальная сумма, длина подстроки

### Fast & Slow Pointers
- Два указателя движутся с разной скоростью
- Применение: поиск цикла, нахождение середины

### DFS vs BFS
- **DFS**: используйте стек или рекурсию, для поиска в глубину
- **BFS**: используйте очередь, для поиска кратчайшего пути

### Dynamic Programming
1. Определите рекуррентное соотношение
2. Определите базовые случаи
3. Выберите подход: мемоизация (top-down) или табуляция (bottom-up)
4. Оптимизируйте пространство, если возможно

### Greedy vs DP
- **Greedy**: локально оптимальный выбор → глобальный оптимум
- **DP**: решение подзадач → оптимальное решение
- Greedy быстрее, но работает не всегда

## План изучения (12 недель)

### Недели 1-2: Основы
- ✅ Анализ сложности (Big O)
- ✅ Массивы и строки
- ✅ Базовые техники (Two Pointers, Sliding Window)

### Недели 3-4: Структуры данных
- ✅ Связные списки
- ✅ Стек и очередь
- ✅ HashMap

### Недели 5-6: Деревья и графы
- ✅ Бинарные деревья
- ✅ BST
- ✅ DFS и BFS
- ✅ Dijkstra

### Недели 7-8: Сортировки
- ✅ Простые сортировки (Bubble, Selection, Insertion)
- ✅ Эффективные сортировки (Quick, Merge, Heap)
- ✅ Анализ и сравнение

### Недели 9-10: Рекурсия и DP
- ✅ Основы рекурсии
- ✅ Backtracking
- ✅ Динамическое программирование
- ✅ Мемоизация vs табуляция

### Недели 11-12: Продвинутые темы
- ✅ Жадные алгоритмы
- ✅ Комбинированные задачи
- ✅ Оптимизация решений

---

**Организация структуры**: Ноябрь 2025  
**Последнее обновление**: 05.11.2025  
**Всего примеров**: 23 файла
