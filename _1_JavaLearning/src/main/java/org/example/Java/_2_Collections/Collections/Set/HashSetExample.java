package org.example.Java._2_Collections.Collections.Set;

import java.util.HashSet;
import java.util.Iterator;

/**
 * УЧЕБНОЕ ПОСОБИЕ: HashSet в Java
 *
 * ЧТО ТАКОЕ HashSet?
 * HashSet - это класс из Java Collections Framework, который реализует интерфейс Set.
 * Это коллекция, которая хранит только уникальные элементы и не допускает дубликатов.
 *
 * ВНУТРЕННЕЕ УСТРОЙСТВО:
 * - Внутри использует HashMap для хранения данных
 * - Элементы хранятся в виде ключей HashMap (значения - константный объект PRESENT)
 * - Использует хеш-таблицу (массив связанных списков/деревьев)
 * - Каждый элемент размещается в определенном "бакете" на основе хеш-кода
 *
 * ХАРАКТЕРИСТИКИ:
 * - Не сохраняет порядок добавления элементов
 * - Не допускает дубликаты
 * - Позволяет хранить один null элемент
 * - НЕ потокобезопасен (не synchronized)
 * - Начальная емкость по умолчанию: 16 бакетов
 * - Коэффициент загрузки (load factor) по умолчанию: 0.75
 *
 * ВРЕМЕННАЯ СЛОЖНОСТЬ (Big O):
 * - add() - O(1) в среднем
 * - remove() - O(1) в среднем
 * - contains() - O(1) в среднем
 * - size() - O(1)
 *
 * @author Учебное пособие
 * @version 2.0
 */
public class HashSetExample {

    public static void main(String[] args) {

        // ======================================
        // 1. СОЗДАНИЕ HashSet
        // ======================================

        /**
         * Конструктор по умолчанию создает HashSet с:
         * - начальной емкостью = 16
         * - коэффициентом загрузки = 0.75
         *
         * Когда количество элементов превышает (емкость * loadFactor),
         * происходит rehashing - увеличение емкости в 2 раза
         */
        HashSet<String> mySet = new HashSet<>();

        // Альтернативные конструкторы:
        // HashSet<String> mySet2 = new HashSet<>(32); // начальная емкость 32
        // HashSet<String> mySet3 = new HashSet<>(32, 0.8f); // емкость 32, load factor 0.8

        System.out.println("=== ДОБАВЛЕНИЕ ЭЛЕМЕНТОВ ===");

        // ======================================
        // 2. ДОБАВЛЕНИЕ ЭЛЕМЕНТОВ - метод add()
        // ======================================

        /**
         * АЛГОРИТМ add():
         * 1. Вычисляется хеш-код элемента через метод hashCode()
         * 2. Хеш-код преобразуется в индекс бакета: index = hash & (capacity - 1)
         * 3. Проверяется, есть ли уже такой элемент в бакете (через equals())
         * 4. Если элемента нет - добавляется, если есть - игнорируется
         *
         * Возвращаемое значение:
         * - true - если элемент был добавлен
         * - false - если элемент уже существует
         */
        boolean added1 = mySet.add("apple");    // вернет true
        boolean added2 = mySet.add("banana");   // вернет true
        boolean added3 = mySet.add("cherry");   // вернет true

        System.out.println("Добавлен 'apple': " + added1);
        System.out.println("Добавлен 'banana': " + added2);

        /**
         * ВАЖНО: Попытка добавить дубликат!
         * HashSet НЕ ДОПУСКАЕТ дубликаты.
         * Метод add() вернет false, элемент не будет добавлен повторно
         */
        boolean added4 = mySet.add("banana");   // вернет false - дубликат!
        System.out.println("Добавлен дубликат 'banana': " + added4);

        /**
         * Вывод содержимого HashSet
         * ВНИМАНИЕ: Порядок элементов НЕ гарантирован!
         * Элементы могут выводиться в любом порядке
         */
        System.out.println("HashSet содержит: " + mySet);
        System.out.println("Размер HashSet: " + mySet.size());

        System.out.println("\n=== УДАЛЕНИЕ ЭЛЕМЕНТОВ ===");

        // ======================================
        // 3. УДАЛЕНИЕ ЭЛЕМЕНТОВ - метод remove()
        // ======================================

        /**
         * АЛГОРИТМ remove():
         * 1. Вычисляется хеш-код удаляемого элемента
         * 2. Находится соответствующий бакет
         * 3. В бакете ищется элемент через equals()
         * 4. Если найден - удаляется
         *
         * Возвращаемое значение:
         * - true - если элемент был найден и удален
         * - false - если элемент не найден
         */
        boolean removed1 = mySet.remove("cherry");  // вернет true
        System.out.println("Удален 'cherry': " + removed1);

        boolean removed2 = mySet.remove("orange");  // вернет false - нет такого элемента
        System.out.println("Попытка удалить несуществующий 'orange': " + removed2);

        System.out.println("\n=== ПРОВЕРКА НАЛИЧИЯ ЭЛЕМЕНТА ===");

        // ======================================
        // 4. ПРОВЕРКА НАЛИЧИЯ - метод contains()
        // ======================================

        /**
         * АЛГОРИТМ contains():
         * 1. Вычисляется хеш-код проверяемого элемента
         * 2. Находится соответствующий бакет
         * 3. В бакете ищется элемент через equals()
         *
         * Возвращает:
         * - true - если элемент найден
         * - false - если элемент не найден
         *
         * Очень быстрая операция O(1) в среднем!
         */
        if (mySet.contains("banana")) {
            System.out.println("✓ Множество содержит элемент 'banana'");
        }

        if (!mySet.contains("cherry")) {
            System.out.println("✗ Множество НЕ содержит элемент 'cherry' (был удален)");
        }

        System.out.println("\n=== ИТОГОВОЕ СОСТОЯНИЕ ===");
        System.out.println("HashSet после всех операций: " + mySet);
        System.out.println("Итоговый размер: " + mySet.size());

        // ======================================
        // 5. ДОПОЛНИТЕЛЬНЫЕ ПОЛЕЗНЫЕ ОПЕРАЦИИ
        // ======================================

        System.out.println("\n=== ДОПОЛНИТЕЛЬНЫЕ ОПЕРАЦИИ ===");

        // Проверка на пустоту
        System.out.println("HashSet пуст? " + mySet.isEmpty());

        // Добавление нескольких элементов для демонстрации
        mySet.add("grape");
        mySet.add("melon");
        mySet.add("kiwi");

        System.out.println("Расширенный HashSet: " + mySet);

        // ======================================
        // 6. ИТЕРАЦИЯ ПО ЭЛЕМЕНТАМ
        // ======================================

        System.out.println("\n=== СПОСОБЫ ОБХОДА ЭЛЕМЕНТОВ ===");

        // Способ 1: Enhanced for loop (рекомендуется)
        System.out.println("Способ 1 - Enhanced for:");
        for (String fruit : mySet) {
            System.out.println("  - " + fruit);
        }

        // Способ 2: Iterator (для удаления во время обхода)
        System.out.println("\nСпособ 2 - Iterator:");
        Iterator<String> iterator = mySet.iterator();
        while (iterator.hasNext()) {
            String fruit = iterator.next();
            System.out.println("  - " + fruit);
            // Можно безопасно удалять: iterator.remove();
        }

        // Способ 3: forEach с лямбда-выражением (Java 8+)
        System.out.println("\nСпособ 3 - forEach с лямбда:");
        mySet.forEach(fruit -> System.out.println("  - " + fruit));

        // ======================================
        // 7. ОПЕРАЦИИ НАД МНОЖЕСТВАМИ
        // ======================================

        System.out.println("\n=== ОПЕРАЦИИ НАД МНОЖЕСТВАМИ ===");

        HashSet<String> set1 = new HashSet<>();
        set1.add("apple");
        set1.add("banana");
        set1.add("cherry");

        HashSet<String> set2 = new HashSet<>();
        set2.add("banana");
        set2.add("cherry");
        set2.add("date");

        // Объединение (Union) - все уникальные элементы из обоих множеств
        HashSet<String> union = new HashSet<>(set1);
        union.addAll(set2);
        System.out.println("Объединение: " + union);

        // Пересечение (Intersection) - только общие элементы
        HashSet<String> intersection = new HashSet<>(set1);
        intersection.retainAll(set2);
        System.out.println("Пересечение: " + intersection);

        // Разность (Difference) - элементы из set1, которых нет в set2
        HashSet<String> difference = new HashSet<>(set1);
        difference.removeAll(set2);
        System.out.println("Разность (set1 - set2): " + difference);

        // ======================================
        // 8. ОЧИСТКА КОЛЛЕКЦИИ
        // ======================================

        System.out.println("\n=== ОЧИСТКА ===");

        // Создаем копию для демонстрации
        HashSet<String> tempSet = new HashSet<>(mySet);
        System.out.println("До очистки: " + tempSet);

        // Удаляет все элементы
        tempSet.clear();
        System.out.println("После clear(): " + tempSet);
        System.out.println("Размер после очистки: " + tempSet.size());
    }
}

/**
 * =====================================
 * ГДЕ ИСПОЛЬЗОВАТЬ HashSet?
 * =====================================
 *
 * ✓ ПОДХОДИТ ДЛЯ:
 * 1. Удаление дубликатов из коллекции
 * 2. Быстрая проверка наличия элемента (contains)
 * 3. Хранение уникальных значений (ID, теги, ключевые слова)
 * 4. Математические операции над множествами
 * 5. Кэширование уникальных объектов
 * 6. Фильтрация данных
 *
 * ✗ НЕ ПОДХОДИТ ДЛЯ:
 * 1. Когда нужен порядок элементов (используйте LinkedHashSet)
 * 2. Когда нужна сортировка (используйте TreeSet)
 * 3. Многопоточной среды без синхронизации
 * 4. Когда нужны дубликаты (используйте List)
 *
 * =====================================
 * ПЛЮСЫ (+):
 * =====================================
 * + Очень быстрые операции O(1): add, remove, contains
 * + Автоматическое удаление дубликатов
 * + Эффективное использование памяти для больших коллекций
 * + Поддержка null значения
 * + Простой и понятный API
 * + Динамическое изменение размера
 *
 * =====================================
 * МИНУСЫ (-):
 * =====================================
 * - НЕ сохраняет порядок элементов
 * - НЕ потокобезопасен (требует внешней синхронизации)
 * - Не поддерживает индексный доступ
 * - Требует корректной реализации hashCode() и equals()
 * - Производительность зависит от качества хеш-функции
 * - Потребляет больше памяти, чем ArrayList
 *
 * =====================================
 * ВАЖНЫЕ ЗАМЕЧАНИЯ:
 * =====================================
 *
 * 1. HASHCODE И EQUALS:
 *    При добавлении пользовательских объектов ОБЯЗАТЕЛЬНО
 *    переопределяйте методы hashCode() и equals()!
 *
 * 2. ПРОИЗВОДИТЕЛЬНОСТЬ:
 *    В худшем случае (плохая хеш-функция) операции могут
 *    деградировать до O(n), но это крайне редко
 *
 * 3. ПОТОКОБЕЗОПАСНОСТЬ:
 *    Для многопоточности используйте:
 *    Set<String> syncSet = Collections.synchronizedSet(new HashSet<>());
 *    или ConcurrentHashMap.newKeySet()
 *
 * 4. LOAD FACTOR:
 *    Значение 0.75 - оптимальный баланс между памятью и скоростью
 *    Меньше = больше памяти, быстрее
 *    Больше = меньше памяти, медленнее
 */
