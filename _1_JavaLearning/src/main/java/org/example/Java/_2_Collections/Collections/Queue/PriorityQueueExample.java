package org.example.Java._2_Collections.Collections.Queue;

import java.util.PriorityQueue;
import java.util.Queue;

/**
 * Демонстрационный класс, показывающий базовую работу с интерфейсом Queue и реализацией PriorityQueue.[web:134]
 *
 * Queue — это очередь (обычно FIFO: первый вошёл — первый вышел), но конкретная реализация может задавать свой порядок.[web:132]
 * Основные методы Queue:[web:120]
 * - offer(E e) — добавить элемент в очередь (возвращает true/false в зависимости от успеха).[web:134]
 * - poll() — забрать и удалить элемент с «головы» очереди; если очередь пустая — вернуть null.[web:120]
 * - peek() — посмотреть элемент на голове очереди, не удаляя его; если очередь пустая — вернуть null.[web:120]
 *
 * PriorityQueue — это очередь с приоритетами: элементы извлекаются не в порядке добавления, а по приоритету.[web:118]
 * Приоритет определяется либо «естественным порядком» элементов (Comparable), либо переданным Comparator в конструктор.[web:118]
 * Внутри PriorityQueue обычно реализована структура «минимальная куча» (min-heap), поэтому по умолчанию первым извлекается наименьший элемент.[web:121]
 *
 * Важно: порядок, в котором элементы возвращаются методами poll/peek, соответствует приоритету,
 * но порядок при простом выводе коллекции (toString, for-each) не обязан быть полностью отсортированным.[web:125]
 */
public class PriorityQueueExample {
    public static void main(String[] args) {
        // Обычно с очередями работают через интерфейс Queue.[web:134]
        // Здесь указываем конкретную реализацию — PriorityQueue<User>.[web:118]
        // Без компаратора очередь будет использовать "естественный порядок" User (метод compareTo). [web:118]
        Queue<User> pq = new PriorityQueue<>();

        // Добавление пользователей в очередь приоритетов.[web:118]
        // Метод offer добавляет элемент в очередь, если это возможно (в PriorityQueue, как правило, всегда успешно).[web:134]
        // Приоритет здесь определяется age (возраст): чем меньше возраст, тем выше приоритет (см. compareTo в классе User).[web:118]
        pq.offer(new User("John", 30));
        pq.offer(new User("Alice", 25));
        pq.offer(new User("Bob", 35));
        pq.offer(new User("Kate", 20));

        // Прямой вывод очереди через toString не гарантирует строгую отсортированность по приоритету,
        // так как внутренняя структура — куча, а не отсортированный список.[web:125]
        System.out.println("Элементы очереди (внутреннее представление): " + pq);

        // Извлечение пользователей из очереди приоритетов.[web:118]
        // Метод poll забирает элемент с наивысшим приоритетом и удаляет его из очереди.[web:120]
        // Если очередь пустая, вернёт null, а не выбросит исключение.[web:132]
        User first = pq.poll();
        User second = pq.poll();

        // Вывод на экран извлеченных пользователей.[web:118]
        // Так как приоритет основан на возрасте по возрастанию, сначала должна быть "Kate" (20), затем "Alice" (25).[web:118]
        System.out.println("Первый пользователь (минимальный возраст): " + first);
        System.out.println("Второй пользователь: " + second);

        // Теперь создаём ещё одну очередь, но уже с явным компаратором.[web:119]
        // Лямбда (u1, u2) -> u2.getAge() - u1.getAge() задаёт обратный порядок по возрасту:
        // чем больше возраст, тем выше приоритет (получается max-heap по age).[web:115]
        PriorityQueue<User> pq2 = new PriorityQueue<>(
                (u1, u2) -> u2.getAge() - u1.getAge()
        );

        // Добавление тех же пользователей во вторую очередь.[web:124]
        pq2.offer(new User("John", 30));
        pq2.offer(new User("Alice", 25));
        pq2.offer(new User("Bob", 35));
        pq2.offer(new User("Kate", 20));

        // Снова выводим очередь целиком.[web:121]
        // Порядок в toString не обязан быть строго отсортированным, но poll/peek будут уважать заданный компаратор.[web:125]
        System.out.println("Элементы очереди с использованием компаратора (внутреннее представление): " + pq2);

        // peek возвращает элемент с наивысшим приоритетом, но не удаляет его.[web:120]
        // Если очередь пустая, вернёт null.[web:132]
        User firstUser = pq2.peek();

        // Вывод на экран первого пользователя очереди по приоритету, заданному компаратором.[web:124]
        // Здесь это должен быть пользователь с максимальным возрастом — "Bob" (35).[web:124]
        System.out.println("Первый пользователь очереди с использованием компаратора: " + firstUser);
    }
}

/**
 * Простой класс пользователя для примера с PriorityQueue.[web:118]
 *
 * Реализует Comparable<User>, чтобы задать "естественный порядок" (natural ordering) по возрасту.[web:118]
 * Это позволяет использовать User в PriorityQueue без явного компаратора: очередь будет упорядочивать по age по возрастанию.[web:121]
 */
class User implements Comparable<User> {
    // Поля помечены final, так как после создания пользователя его имя и возраст не меняются.[web:118]
    private final String name;
    private final int age;

    /**
     * Конструктор для инициализации полей name и age.[web:118]
     */
    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    /**
     * Геттер для имени пользователя.[web:118]
     */
    public String getName() {
        return name;
    }

    /**
     * Геттер для возраста пользователя.[web:118]
     */
    public int getAge() {
        return age;
    }

    /**
     * Определяет "естественный порядок" пользователей по возрасту.[web:118]
     *
     * Integer.compare(this.age, other.age) возвращает:[web:121]
     * - отрицательное число, если this.age < other.age;[web:121]
     * - ноль, если возраста равны;[web:121]
     * - положительное число, если this.age > other.age.[web:121]
     *
     * Для PriorityQueue это означает: чем меньше возраст, тем выше приоритет при использовании этой реализации Comparable.[web:118]
     */
    @Override
    public int compareTo(User other) {
        return Integer.compare(this.age, other.age);
    }

    /**
     * Переопределяем toString, чтобы вывод пользователя в консоль был наглядным.[web:118]
     */
    @Override
    public String toString() {
        return "User{name='" + name + "', age=" + age + "}";
    }
}
