package org.example.Java._2_Collections.Map;

import java.util.LinkedHashMap;
import java.util.Map;

/**
 * УЧЕБНОЕ ПОСОБИЕ: LinkedHashMap в Java
 *
 * ЧТО ТАКОЕ LinkedHashMap?
 * LinkedHashMap - это расширение класса HashMap.
 * Он сохраняет все преимущества HashMap (быстрый поиск O(1)), но добавляет
 * сохранение ПОРЯДКА элементов.
 *
 * ВНУТРЕННЕЕ УСТРОЙСТВО:
 * Это гибрид двух структур данных:
 * 1. Хеш-таблица (как в HashMap) - для быстрого хранения и поиска.
 * 2. Двусвязный список (Doubly Linked List) - пронизывает все элементы для хранения порядка.
 *
 * СТРУКТУРА УЗЛА (Entry):
 * В отличие от HashMap, узел здесь содержит две дополнительные ссылки:
 * class Entry<K,V> extends HashMap.Node<K,V> {
 *     Entry<K,V> before; // Ссылка на предыдущий добавленный/использованный элемент
 *     Entry<K,V> after;  // Ссылка на следующий добавленный/использованный элемент
 * }
 *
 * РЕЖИМЫ ПОРЯДКА (Ordering Modes):
 * 1. Insertion Order (По умолчанию):
 *    Порядок, в котором ключи были добавлены в карту.
 *    Используется: new LinkedHashMap<>();
 *
 * 2. Access Order (Режим доступа):
 *    Порядок меняется при каждом обращении к элементу (get, put).
 *    Элемент, к которому обратились, перемещается в КОНЕЦ списка.
 *    Используется: new LinkedHashMap<>(cap, loadFactor, true);
 *    Идеально для создания LRU Cache (Least Recently Used).
 *
 * ВИЗУАЛИЗАЦИЯ (Access Order):
 * Список: [A] <-> [B] <-> [C]
 * Вызываем get("A") -> "A" перемещается в хвост.
 * Список: [B] <-> [C] <-> [A]
 *
 * ХАРАКТЕРИСТИКИ:
 * - Потокобезопасность: НЕТ (как и HashMap).
 * - Null ключи: РАЗРЕШЕНЫ.
 * - Скорость: Чуть медленнее HashMap при вставке/удалении (нужно менять ссылки списка),
 *   но быстрее при итерации (ходит по списку, а не по пустым корзинам массива).
 *
 * @author Учебное пособие
 * @version 2.0
 */
public class LinkedHashMapExample {

    public static void main(String[] args) {

        // ======================================
        // 1. СОЗДАНИЕ LinkedHashMap
        // ======================================

        /**
         * Конструктор с 3 параметрами для включения "Access Order":
         * 1. initialCapacity (16) - начальный размер хеш-таблицы.
         * 2. loadFactor (0.75f) - коэффициент загрузки (когда увеличивать массив).
         * 3. accessOrder (true) - ВАЖНО!
         *    - false: порядок вставки (как добавили, так и лежат).
         *    - true:  порядок доступа (последний использованный идет в конец).
         */
        System.out.println("=== СОЗДАНИЕ КАРТЫ (Access Order = true) ===");
        LinkedHashMap<String, Integer> scores = new LinkedHashMap<>(16, 0.75f, true);

        // ======================================
        // 2. ДОБАВЛЕНИЕ ЭЛЕМЕНТОВ
        // ======================================

        System.out.println("\n=== ДОБАВЛЕНИЕ (put) ===");

        scores.put("Alice", 95);
        scores.put("Bob", 83);
        scores.put("Charlie", 77);

        /**
         * Состояние после добавления (порядок вставки):
         * Head -> [Alice] -> [Bob] -> [Charlie] -> Tail
         * Самый старый: Alice
         * Самый новый: Charlie
         */
        System.out.println("Текущий порядок: " + scores);


        // ======================================
        // 3. ВЛИЯНИЕ МЕТОДА get() НА ПОРЯДОК
        // ======================================

        System.out.println("\n=== ДОСТУП К ЭЛЕМЕНТАМ (get) ===");
        System.out.println("Обратите внимание, как меняется порядок при чтении!");

        // 1. Читаем Alice
        System.out.println("--> Вызываем scores.get(\"Alice\"): " + scores.get("Alice"));
        /**
         * ЧТО ПРОИЗОШЛО ВНУТРИ?
         * Так как accessOrder = true, "Alice" вынимается из текущей позиции
         * и помещается в КОНЕЦ списка (становится "самым свежим").
         *
         * Было:  Alice, Bob, Charlie
         * Стало: Bob, Charlie, Alice
         */
        System.out.println("   Порядок после Alice: " + scores);


        // 2. Читаем Bob
        System.out.println("--> Вызываем scores.get(\"Bob\"): " + scores.get("Bob"));
        /**
         * "Bob" перемещается в конец списка.
         *
         * Было:  Bob, Charlie, Alice
         * Стало: Charlie, Alice, Bob
         */
        System.out.println("   Порядок после Bob:   " + scores);

        // ======================================
        // 4. ОБХОД ЭЛЕМЕНТОВ
        // ======================================

        System.out.println("\n=== ИТОГОВЫЙ ОБХОД (ИМИТАЦИЯ LRU) ===");
        System.out.println("Порядок: от 'давно не использованных' к 'недавно использованным'");

        for (Map.Entry<String, Integer> entry : scores.entrySet()) {
            System.out.println(" - " + entry.getKey() + " : " + entry.getValue());
        }

        /**
         * РЕЗУЛЬТАТ:
         * 1. Charlie (мы его добавили и больше не трогали -> он в начале, кандидат на удаление)
         * 2. Alice   (трогали пред-последней)
         * 3. Bob     (трогали последним -> он в конце, самый "свежий")
         */

        // ======================================
        // 5. ПРАКТИЧЕСКОЕ ПРИМЕНЕНИЕ: LRU Cache
        // ======================================

        System.out.println("\n=== ЗАЧЕМ ЭТО НУЖНО? (LRU Cache) ===");
        System.out.println("LinkedHashMap позволяет легко сделать кэш фиксированного размера.");
        System.out.println("Если переопределить метод removeEldestEntry(), карта будет сама");
        System.out.println("удалять самый старый (первый в списке) элемент при добавлении нового.");

        // Пример создания простого кэша на 2 элемента:
        LinkedHashMap<String, String> simpleCache = new LinkedHashMap<String, String>(16, 0.75f, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry<String, String> eldest) {
                return size() > 2; // Удалять старейший, если размер > 2
            }
        };

        simpleCache.put("1", "One");
        simpleCache.put("2", "Two");
        simpleCache.put("3", "Three"); // "1" удалится, так как она самая старая

        System.out.println("LRU Кэш (осталось только 2 последних): " + simpleCache);
    }
}

/**
 * =====================================
 * СРАВНЕНИЕ: HashMap vs LinkedHashMap
 * =====================================
 *
 * ┌───────────────┬───────────────────────────┬─────────────────────────────┐
 * │ Характеристика│ HashMap                   │ LinkedHashMap               │
 * ├───────────────┼───────────────────────────┼─────────────────────────────┤
 * │ Структура     │ Массив + Список/Дерево    │ Массив + Двусвязный список  │
 * │               │ (только для коллизий)     │ (для всех элементов)        │
 * │ Порядок       │ Хаотичный                 │ Вставки или Доступа         │
 * │ Память        │ Меньше (Node проще)       │ Больше (Node хранит ссылки  │
 * │               │                           │ before/after)               │
 * │ Скорость put  │ O(1)                      │ O(1) (но чуть медленнее из- │
 * │               │                           │ за перелинковки списка)     │
 * │ Итерация      │ Зависит от Capacity       │ Зависит от Size (быстрее,   │
 * │               │ (перебор всех ячеек)      │ если карта полупустая)      │
 * └───────────────┴───────────────────────────┴─────────────────────────────┘
 *
 * =====================================
 * КОГДА ИСПОЛЬЗОВАТЬ?
 * =====================================
 *
 * 1. Вам нужен Map, но важен порядок вывода (например, в JSON порядке полей).
 * 2. Вы реализуете LRU Cache (кэш недавно использованных элементов).
 * 3. Вам нужно хранить историю переходов/действий пользователя.
 *
 * Если порядок не важен — всегда выбирайте обычный HashMap, он ест меньше памяти.
 */