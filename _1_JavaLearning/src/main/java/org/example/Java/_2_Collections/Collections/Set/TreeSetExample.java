package org.example.Java._2_Collections.Collections.Set;

import java.util.TreeSet;
import java.util.Iterator;
import java.util.Comparator;

/**
 * УЧЕБНОЕ ПОСОБИЕ: TreeSet в Java

 * ЧТО ТАКОЕ TreeSet?
 * TreeSet - это класс из Java Collections Framework, который реализует интерфейс NavigableSet.
 * Это коллекция, которая хранит УНИКАЛЬНЫЕ элементы в ОТСОРТИРОВАННОМ порядке.

 * ВНУТРЕННЕЕ УСТРОЙСТВО:
 * - Внутри использует TreeMap для хранения данных
 * - Элементы хранятся в виде ключей TreeMap (значения - константный объект PRESENT)
 * - Использует КРАСНО-ЧЕРНОЕ ДЕРЕВО (Red-Black Tree)
 * - Красно-черное дерево - это самобалансирующееся бинарное дерево поиска

 * СТРУКТУРА КРАСНО-ЧЕРНОГО ДЕРЕВА:
 *              5 (черный - корень)
 *            /   \
 *      2 (красный) 8 (красный)
 *                 / \
 *          7 (черный) 10 (черный)
 *
 * ПРАВИЛА КРАСНО-ЧЕРНОГО ДЕРЕВА:
 * 1. Каждый узел либо КРАСНЫЙ, либо ЧЕРНЫЙ
 * 2. Корень всегда ЧЕРНЫЙ
 * 3. Все листья (null) - ЧЕРНЫЕ
 * 4. Если узел КРАСНЫЙ - оба его потомка ЧЕРНЫЕ
 * 5. Все пути от узла к листьям содержат одинаковое количество черных узлов
 *
 * ХАРАКТЕРИСТИКИ:
 * - Автоматическая сортировка элементов (по возрастанию по умолчанию)
 * - Не допускает дубликаты
 * - НЕ допускает null элементы (вызовет NullPointerException!)
 * - НЕ потокобезопасен (не synchronized)
 * - Гарантирует порядок элементов
 *
 * ВРЕМЕННАЯ СЛОЖНОСТЬ (Big O):
 * - add() - O(log n) - нужно найти место и перебалансировать
 * - remove() - O(log n) - нужно найти и перебалансировать
 * - contains() - O(log n) - бинарный поиск по дереву
 * - first() / last() - O(log n)
 * - size() - O(1)
 *
 * ОТЛИЧИЯ ОТ HashSet:
 * ┌──────────────┬─────────────────┬─────────────────┐
 * │ Критерий     │ HashSet         │ TreeSet         │
 * ├──────────────┼─────────────────┼─────────────────┤
 * │ Структура    │ Хеш-таблица     │ Красно-черное   │
 * │              │                 │ дерево          │
 * │ Порядок      │ НЕТ             │ ДА (сортировка) │
 * │ Null         │ Один null       │ НЕТ null        │
 * │ Скорость     │ O(1)            │ O(log n)        │
 * │ Использование│ Быстрый доступ  │ Нужна сортировка│
 * └──────────────┴─────────────────┴─────────────────┘
 *
 * @author Учебное пособие
 * @version 2.0
 */
public class TreeSetExample {

    public static void main(String[] args) {

        // ======================================
        // 1. СОЗДАНИЕ TreeSet
        // ======================================

        /**
         * Конструктор по умолчанию создает TreeSet с:
         * - естественной сортировкой (элементы должны реализовать Comparable)
         * - порядок по возрастанию для чисел: 1, 2, 3, ...
         * - алфавитный порядок для строк: "a", "b", "c", ...
         */
        TreeSet<Integer> mySet = new TreeSet<>();

        // Альтернативные конструкторы:
        // TreeSet<Integer> descSet = new TreeSet<>(Comparator.reverseOrder()); // по убыванию
        // TreeSet<Integer> customSet = new TreeSet<>((a, b) -> b - a); // свой компаратор

        System.out.println("=== ДОБАВЛЕНИЕ ЭЛЕМЕНТОВ ===");

        // ======================================
        // 2. ДОБАВЛЕНИЕ ЭЛЕМЕНТОВ - метод add()
        // ======================================

        /**
         * АЛГОРИТМ add() В КРАСНО-ЧЕРНОМ ДЕРЕВЕ:
         *
         * 1. Если дерево пустое - новый элемент становится корнем (черным)
         * 2. Бинарный поиск места вставки:
         *    - Если новый < текущий → идем влево
         *    - Если новый > текущий → идем вправо
         *    - Если новый == текущий → НЕ добавляем (дубликат!)
         * 3. Вставляем новый узел как КРАСНЫЙ
         * 4. БАЛАНСИРОВКА дерева (повороты и перекрашивание):
         *    - Левый поворот
         *    - Правый поворот
         *    - Перекрашивание узлов
         *
         * ШАГ ЗА ШАГОМ:
         * Добавляем 10: дерево = [10(черный)]
         * Добавляем 2:  дерево = [10(черный)]
         *                        /
         *                   [2(красный)]
         * Добавляем 8:  дерево = [8(черный)] ← после балансировки
         *                        /  \
         *                   [2]      [10]
         */

        System.out.println("Добавляем 10...");
        mySet.add(10);  // Первый элемент - становится корнем
        System.out.println("Текущее дерево: " + mySet);

        System.out.println("\nДобавляем 2...");
        mySet.add(2);   // Меньше 10 → идет влево
        System.out.println("Текущее дерево: " + mySet);

        System.out.println("\nДобавляем 8...");
        mySet.add(8);   // 8 < 10 (влево), 8 > 2 (вправо)
        System.out.println("Текущее дерево: " + mySet);

        System.out.println("\nДобавляем 5...");
        mySet.add(5);   // Автоматически находит правильное место
        System.out.println("Текущее дерево: " + mySet);

        /**
         * ВАЖНО: Элементы АВТОМАТИЧЕСКИ ОТСОРТИРОВАНЫ!
         * Не важно, в каком порядке мы добавляли (10, 2, 8, 5)
         * TreeSet ВСЕГДА выводит их в отсортированном виде: [2, 5, 8, 10]
         *
         * ВИЗУАЛИЗАЦИЯ ДЕРЕВА ПОСЛЕ ВСЕХ ДОБАВЛЕНИЙ:
         *           8 (черный)
         *          / \
         *      5 (красный)  10 (черный)
         *     /
         * 2 (красный)
         */
        System.out.println("\n=== РЕЗУЛЬТАТ ДОБАВЛЕНИЯ ===");
        System.out.println("TreeSet содержит: " + mySet);
        System.out.println("Размер: " + mySet.size());
        System.out.println("Обратите внимание: элементы ОТСОРТИРОВАНЫ по возрастанию!");

        // Попытка добавить дубликат
        System.out.println("\n=== ПОПЫТКА ДОБАВИТЬ ДУБЛИКАТ ===");
        boolean added = mySet.add(5);  // 5 уже есть!
        System.out.println("Добавлен дубликат 5? " + added);  // false
        System.out.println("TreeSet: " + mySet);  // дубликат не добавился

        System.out.println("\n=== УДАЛЕНИЕ ЭЛЕМЕНТОВ ===");

        // ======================================
        // 3. УДАЛЕНИЕ ЭЛЕМЕНТОВ - метод remove()
        // ======================================

        /**
         * АЛГОРИТМ remove() В КРАСНО-ЧЕРНОМ ДЕРЕВЕ:
         *
         * 1. Бинарный поиск удаляемого элемента:
         *    - Если ищем < текущий → идем влево
         *    - Если ищем > текущий → идем вправо
         *    - Если ищем == текущий → НАШЛИ!
         *
         * 2. Удаление узла (3 случая):
         *    а) Узел - лист (нет детей): просто удаляем
         *    б) Узел имеет 1 ребенка: заменяем узел его ребенком
         *    в) Узел имеет 2 детей: заменяем узел наименьшим из правого поддерева
         *
         * 3. БАЛАНСИРОВКА после удаления (если нарушены правила дерева)
         *
         * Сложность: O(log n) - поиск + балансировка
         */

        System.out.println("Удаляем элемент 8...");
        boolean removed = mySet.remove(8);
        System.out.println("Элемент 8 удален? " + removed);  // true
        System.out.println("TreeSet после удаления: " + mySet);

        /**
         * ДЕРЕВО ПОСЛЕ УДАЛЕНИЯ 8:
         *         5 (черный) или 10 (черный) - в зависимости от балансировки
         *        / \
         *   2 (красный)  10 (красный)
         */

        System.out.println("\n=== ПРОВЕРКА НАЛИЧИЯ ЭЛЕМЕНТА ===");

        // ======================================
        // 4. ПРОВЕРКА НАЛИЧИЯ - метод contains()
        // ======================================

        /**
         * АЛГОРИТМ contains() - БИНАРНЫЙ ПОИСК:
         *
         * 1. Начинаем с корня дерева
         * 2. Сравниваем искомый элемент с текущим узлом:
         *    - Если искомый == текущий → НАШЛИ! return true
         *    - Если искомый < текущий → идем в ЛЕВОЕ поддерево
         *    - Если искомый > текущий → идем в ПРАВОЕ поддерево
         * 3. Повторяем, пока не найдем или не дойдем до null
         *
         * ПРИМЕР ПОИСКА "2" В ДЕРЕВЕ:
         *         5 (текущий)
         *        / \
         *       2   10
         *
         * Шаг 1: Ищем 2, текущий = 5. 2 < 5 → идем ВЛЕВО
         * Шаг 2: Ищем 2, текущий = 2. 2 == 2 → НАШЛИ!
         *
         * Потребовалось всего 2 сравнения (вместо перебора всех элементов)
         * Сложность: O(log n)
         */

        if (mySet.contains(2)) {
            System.out.println("✓ Множество содержит элемент 2");
            System.out.println("  Поиск выполнен за O(log n) операций");
        }

        if (!mySet.contains(8)) {
            System.out.println("✗ Множество НЕ содержит элемент 8 (был удален)");
        }

        System.out.println("\n=== ИТОГОВОЕ СОСТОЯНИЕ ===");
        System.out.println("TreeSet после всех операций: " + mySet);
        System.out.println("Итоговый размер: " + mySet.size());

        // ======================================
        // 5. УНИКАЛЬНЫЕ МЕТОДЫ TreeSet
        // ======================================

        System.out.println("\n=== СПЕЦИАЛЬНЫЕ МЕТОДЫ TreeSet ===");

        // Добавим еще элементов для демонстрации
        mySet.add(1);
        mySet.add(3);
        mySet.add(7);
        mySet.add(15);
        mySet.add(20);

        System.out.println("Расширенный TreeSet: " + mySet);

        /**
         * first() - получить ПЕРВЫЙ (наименьший) элемент
         * Сложность: O(log n) - идем всегда влево до конца
         */
        System.out.println("\nПервый (минимальный) элемент: " + mySet.first());

        /**
         * last() - получить ПОСЛЕДНИЙ (наибольший) элемент
         * Сложность: O(log n) - идем всегда вправо до конца
         */
        System.out.println("Последний (максимальный) элемент: " + mySet.last());

        /**
         * lower(E e) - элемент СТРОГО меньше указанного
         */
        System.out.println("Элемент меньше 10: " + mySet.lower(10));  // 7

        /**
         * higher(E e) - элемент СТРОГО больше указанного
         */
        System.out.println("Элемент больше 10: " + mySet.higher(10));  // 15

        /**
         * floor(E e) - элемент <= указанного
         */
        System.out.println("Элемент <= 10: " + mySet.floor(10));  // 10

        /**
         * ceiling(E e) - элемент >= указанного
         */
        System.out.println("Элемент >= 10: " + mySet.ceiling(10));  // 10

        /**
         * pollFirst() - УДАЛИТЬ и вернуть первый элемент
         */
        System.out.println("\nУдаляем первый элемент: " + mySet.pollFirst());
        System.out.println("TreeSet после pollFirst(): " + mySet);

        /**
         * pollLast() - УДАЛИТЬ и вернуть последний элемент
         */
        System.out.println("Удаляем последний элемент: " + mySet.pollLast());
        System.out.println("TreeSet после pollLast(): " + mySet);

        // ======================================
        // 6. ОПЕРАЦИИ С ДИАПАЗОНАМИ
        // ======================================

        System.out.println("\n=== ОПЕРАЦИИ С ДИАПАЗОНАМИ ===");

        TreeSet<Integer> numbers = new TreeSet<>();
        for (int i = 1; i <= 20; i++) {
            numbers.add(i);
        }
        System.out.println("Исходный TreeSet: " + numbers);

        /**
         * subSet(from, to) - подмножество [from, to)
         * Возвращает элементы >= from и < to
         */
        System.out.println("\nsubSet(5, 15) - элементы от 5 (вкл.) до 15 (искл.): "
                + numbers.subSet(5, 15));

        /**
         * headSet(to) - элементы < to
         * Все элементы меньше указанного
         */
        System.out.println("headSet(10) - элементы < 10: " + numbers.headSet(10));

        /**
         * tailSet(from) - элементы >= from
         * Все элементы начиная с указанного
         */
        System.out.println("tailSet(15) - элементы >= 15: " + numbers.tailSet(15));

        // ======================================
        // 7. ОБХОД ЭЛЕМЕНТОВ
        // ======================================

        System.out.println("\n=== СПОСОБЫ ОБХОДА ЭЛЕМЕНТОВ ===");

        TreeSet<String> fruits = new TreeSet<>();
        fruits.add("Orange");
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Mango");
        fruits.add("Cherry");

        System.out.println("Исходный порядок добавления: Orange, Apple, Banana, Mango, Cherry");
        System.out.println("Порядок в TreeSet: " + fruits);
        System.out.println("↑ Автоматически отсортированы по алфавиту!");

        // Способ 1: Прямой обход (по возрастанию)
        System.out.println("\n1. Прямой обход (по возрастанию):");
        for (String fruit : fruits) {
            System.out.println("  - " + fruit);
        }

        // Способ 2: Обратный обход (по убыванию)
        System.out.println("\n2. Обратный обход (по убыванию):");
        Iterator<String> descendingIterator = fruits.descendingIterator();
        while (descendingIterator.hasNext()) {
            System.out.println("  - " + descendingIterator.next());
        }

        // Способ 3: Обратный TreeSet
        System.out.println("\n3. Получение обратного TreeSet:");
        TreeSet<String> reversedFruits = (TreeSet<String>) fruits.descendingSet();
        System.out.println("  " + reversedFruits);

        // ======================================
        // 8. ПОЛЬЗОВАТЕЛЬСКАЯ СОРТИРОВКА
        // ======================================

        System.out.println("\n=== ПОЛЬЗОВАТЕЛЬСКАЯ СОРТИРОВКА ===");

        /**
         * ВАЖНО: Для пользовательских объектов нужно:
         * 1. Реализовать интерфейс Comparable
         * ИЛИ
         * 2. Предоставить Comparator при создании TreeSet
         */

        // Сортировка по убыванию
        TreeSet<Integer> descending = new TreeSet<>(Comparator.reverseOrder());
        descending.add(5);
        descending.add(1);
        descending.add(10);
        descending.add(3);
        System.out.println("Сортировка по убыванию: " + descending);

        // Сортировка строк по длине
        TreeSet<String> byLength = new TreeSet<>(Comparator.comparingInt(String::length));
        byLength.add("Java");
        byLength.add("C");
        byLength.add("Python");
        byLength.add("Go");
        System.out.println("Сортировка по длине строки: " + byLength);

        // ======================================
        // 9. СРАВНЕНИЕ С HashSet
        // ======================================

        System.out.println("\n=== СРАВНЕНИЕ ПРОИЗВОДИТЕЛЬНОСТИ ===");

        // TreeSet - гарантирует порядок, но медленнее
        TreeSet<Integer> treeSet = new TreeSet<>();
        long startTree = System.nanoTime();
        for (int i = 0; i < 1000; i++) {
            treeSet.add(i);
        }
        long endTree = System.nanoTime();

        System.out.println("TreeSet: " + (endTree - startTree) + " наносекунд");
        System.out.println("  - Элементы отсортированы: " + treeSet.size() + " элементов");
        System.out.println("  - Первый элемент: " + treeSet.first());
        System.out.println("  - Последний элемент: " + treeSet.last());

        System.out.println("\nВЫВОД: TreeSet медленнее HashSet, но предоставляет:");
        System.out.println("  ✓ Автоматическую сортировку");
        System.out.println("  ✓ Методы для работы с диапазонами");
        System.out.println("  ✓ Навигационные методы (first, last, higher, lower)");
    }
}

/**
 * =====================================
 * ВИЗУАЛИЗАЦИЯ КРАСНО-ЧЕРНОГО ДЕРЕВА
 * =====================================
 *
 * Пример TreeSet с элементами [2, 5, 8, 10, 15]:
 *
 *               8 (Черный - корень)
 *              / \
 *             /   \
 *      5 (Красный) 10 (Черный)
 *         /              \
 *    2 (Черный)      15 (Красный)
 *
 * ОПЕРАЦИИ:
 *
 * 1. ПОИСК "10":
 *    Начало: 8
 *    10 > 8 → идем ВПРАВО
 *    Текущий: 10
 *    10 == 10 → НАШЛИ!
 *    Шагов: 2
 *
 * 2. ДОБАВЛЕНИЕ "12":
 *    Начало: 8
 *    12 > 8 → ВПРАВО
 *    Текущий: 10
 *    12 > 10 → ВПРАВО
 *    Текущий: 15
 *    12 < 15 → ВЛЕВО (место найдено)
 *    Вставляем 12 как КРАСНЫЙ узел
 *    Балансировка не требуется
 *
 * 3. БАЛАНСИРОВКА:
 *    - Левый поворот: когда правый ребенок красный, а левый черный
 *    - Правый поворот: когда левый ребенок красный
 *    - Перекрашивание: изменение цветов узлов
 *
 * =====================================
 * ГДЕ ИСПОЛЬЗОВАТЬ TreeSet?
 * =====================================
 *
 * ✓ ПОДХОДИТ ДЛЯ:
 * 1. Когда нужна автоматическая сортировка элементов
 * 2. Работа с диапазонами данных (от X до Y)
 * 3. Поиск ближайших элементов (больше/меньше заданного)
 * 4. Получение минимума/максимума за O(log n)
 * 5. Статистический анализ данных
 * 6. Лидерборды (рейтинги)
 * 7. Планировщики задач по приоритету
 *
 * ✗ НЕ ПОДХОДИТ ДЛЯ:
 * 1. Когда нужна максимальная скорость (используйте HashSet)
 * 2. Когда порядок не важен
 * 3. Когда нужно хранить null
 * 4. Простая проверка наличия элемента
 * 5. Элементы невозможно сравнить (нет Comparable/Comparator)
 *
 * =====================================
 * ПЛЮСЫ (+):
 * =====================================
 * + Автоматическая сортировка элементов
 * + Гарантированный порядок обхода
 * + Методы для работы с диапазонами (subSet, headSet, tailSet)
 * + Навигационные методы (first, last, higher, lower, ceiling, floor)
 * + Предсказуемая производительность O(log n)
 * + Эффективный поиск элементов (бинарный поиск)
 * + Гарантия уникальности элементов
 * + Можно настроить порядок сортировки через Comparator
 *
 * =====================================
 * МИНУСЫ (-):
 * =====================================
 * - Медленнее чем HashSet (O(log n) вместо O(1))
 * - НЕ допускает null элементы
 * - Требует, чтобы элементы были сравнимы (Comparable или Comparator)
 * - НЕ потокобезопасен
 * - Потребляет больше памяти (узлы дерева хранят цвет и ссылки)
 * - Сложнее внутренняя реализация (балансировка дерева)
 *
 * =====================================
 * ВАЖНЫЕ ЗАМЕЧАНИЯ:
 * =====================================
 *
 * 1. NULL ЭЛЕМЕНТЫ:
 *    TreeSet.add(null) → NullPointerException!
 *    Нельзя сравнивать null с другими элементами
 *
 * 2. COMPARABLE VS COMPARATOR:
 *    // Вариант 1: Класс реализует Comparable
 *    class Person implements Comparable<Person> {
 *        int age;
 *        public int compareTo(Person other) {
 *            return Integer.compare(this.age, other.age);
 *        }
 *    }
 *    TreeSet<Person> set1 = new TreeSet<>();
 *
 *    // Вариант 2: Передаем Comparator
 *    TreeSet<Person> set2 = new TreeSet<>((p1, p2) ->
 *        p1.name.compareTo(p2.name));
 *
 * 3. ПРОИЗВОДИТЕЛЬНОСТЬ:
 *    - HashSet: add/remove/contains = O(1)
 *    - TreeSet: add/remove/contains = O(log n)
 *
 *    Для 1,000,000 элементов:
 *    - HashSet: ~1 операция
 *    - TreeSet: ~20 операций (log₂ 1,000,000 ≈ 20)
 *
 * 4. ПОТОКОБЕЗОПАСНОСТЬ:
 *    Для многопоточности используйте:
 *    SortedSet<Integer> syncSet = Collections.synchronizedSortedSet(new TreeSet<>());
 *    или ConcurrentSkipListSet (thread-safe аналог TreeSet)
 *
 * 5. КОГДА ИСПОЛЬЗОВАТЬ:
 *    HashSet → нужна скорость, порядок не важен
 *    TreeSet → нужна сортировка, работа с диапазонами
 *    LinkedHashSet → нужен порядок вставки
 */
