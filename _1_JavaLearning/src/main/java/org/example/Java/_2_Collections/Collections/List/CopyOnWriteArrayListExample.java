package org.example.Java._2_Collections.Collections.List;

import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

/**
 * Демонстрационный класс, показывающий базовую работу с CopyOnWriteArrayList в Java.[web:55]
 *
 * CopyOnWriteArrayList — это потокобезопасный вариант ArrayList, который находится в пакете java.util.concurrent.[web:65]
 * Внутри он тоже хранит элементы в массиве, но все изменяющие операции (add, remove, set, clear и т.д.)
 * выполняются по принципу «копирование при записи» (copy-on-write).[web:59]
 *
 * Что значит «copy-on-write»:[web:59]
 * - При каждом изменении списка создаётся новая копия внутреннего массива с учётом изменений.[web:65]
 * - Потоки, которые сейчас читают список (через итератор или просто for-each), продолжают работать с старой «снимкой» массива,
 *   поэтому не получают ConcurrentModificationException и видят согласованное состояние данных.[web:59]
 *
 * Важно понимать сильные и слабые стороны CopyOnWriteArrayList:[web:62]
 * - Плюс: безопасное чтение из нескольких потоков без явной синхронизации и без ConcurrentModificationException при итерации.[web:66]
 * - Плюс: очень быстрые операции чтения (чтение не блокируется, можно много параллельных читателей).[web:62]
 * - Минус: любые изменения дорогие по памяти и времени, потому что создаётся новая копия массива.[web:60]
 * - Вывод: CopyOnWriteArrayList подходит для сценариев, где очень много чтения и мало изменений (например, список подписчиков, конфигураций и т.д.).[web:69]
 *
 * В этом учебном примере НЕ показывается многопоточность, а только базовый синтаксис работы со списком:
 * создание, добавление элементов, обход, удаление — но с пояснением, чем он концептуально отличается от обычного ArrayList.[web:55]
 */
public class CopyOnWriteArrayListExample {

    /**
     * Точка входа в программу.[web:55]
     *
     * Здесь демонстрируются:[web:56]
     * - создание CopyOnWriteArrayList через интерфейс List;[web:59]
     * - добавление элементов (add);[web:56]
     * - обход списка в цикле for-each;[web:59]
     * - удаление элемента (remove);[web:56]
     * - пояснение, почему этот список полезен в многопоточной среде, даже если сам код однопоточный.[web:62]
     */
    public static void main(String[] args) {
        // Чаще всего CopyOnWriteArrayList используют через интерфейс List.[web:59]
        // Это хороший стиль — код зависит от интерфейса, а не от конкретной реализации.[web:52]
        List<String> myList = new CopyOnWriteArrayList<>();

        // Добавляем несколько элементов в список с помощью метода add.[web:56]
        // В однопоточном примере это выглядит как обычный ArrayList,
        // но внутри для каждой модификации создаётся новая копия массива.[web:65]
        myList.add("apple");
        myList.add("banana");
        myList.add("cherry");

        System.out.println("Initial list:");

        // Цикл for-each проходит по всем элементам списка.[web:59]
        // Главное отличие в многопоточном контексте: итерация по CopyOnWriteArrayList безопасна,
        // даже если другой поток будет параллельно добавлять/удалять элементы — текущий проход увидит «снимок» списка.[web:62]
        for (String fruit : myList) {
            System.out.println(fruit);
        }

        // Добавляем ещё один элемент.[web:56]
        // Внутри будет создан новый массив, в который скопированы старые элементы + новый элемент.[web:60]
        myList.add("orange");

        System.out.println("After adding new element:");

        // Снова выводим все элементы списка, чтобы увидеть добавленный "orange".[web:59]
        for (String fruit : myList) {
            System.out.println(fruit);
        }

        // Удаляем элемент "banana" из списка.[web:56]
        // CopyOnWriteArrayList снова создаст новый массив без этого элемента.[web:59]
        myList.remove("banana");

        System.out.println("After removing \"banana\":");

        // Ещё раз выводим все элементы, чтобы убедиться, что "banana" больше нет.[web:56]
        for (String fruit : myList) {
            System.out.println(fruit);
        }

        // Важно: несмотря на то, что в этом примере код однопоточный и выглядит как обычная работа со списком,
        // CopyOnWriteArrayList имеет смысл именно тогда, когда много потоков читают список,
        // а записи происходят редко (иначе накладные расходы на копирование будут слишком большими).[web:69]
    }
}
