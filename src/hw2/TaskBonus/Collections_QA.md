# Питання та відповіді щодо колекцій

## ArrayList

### 1. Де застосовувати arraylist на практиці? А де linkedlist?

**ArrayList**: коли потрібен швидкий доступ до елементів за індексом, рідко змінюється розмір.
Наприклад:
- Кеш даних
- Списки елементів інтерфейсу
- Зберігання результатів запитів

**LinkedList**: коли часто додаються/видаляються елементи в середині колекції.
Наприклад:
- Черги повідомлень
- Історія дій для скасування
- Реалізація графів

### 2. Як зробити ArrayList незмінним, та для чого це може бути корисно?

Можна використати `Collections.unmodifiableList(list)`. Це корисно для:
- Захисту даних від випадкових змін
- Забезпечення потокобезпечності
- Кешування
- Дотримання API контрактів

### 3. Наскільки робота з ArrayList повільніше роботи зі звичайним Java-масивом?

Доступ за індексом майже однаковий (O(1)), але ArrayList має невеликі накладні витрати на boxing/unboxing для примітивів та перевірки індексів. Різниця зазвичай незначна.

### 4. Який коефіцієнт розширення краще використовувати для ArrayList?

Стандартний коефіцієнт 1.5 (в Java) або 2 є хорошим компромісом між частотою розширення та витратами пам'яті. Менший коефіцієнт призводить до частіших розширень, більший - до надмірного використання пам'яті.

**У моїй реалізації MyArrayList** використовується коефіцієнт розширення 2, що видно з методу resize():
```java
private void resize() {
    int newCapacity = elements.length * 2;
    Object[] newElements = new Object[newCapacity];
    System.arraycopy(elements, 0, newElements, 0, size);
    elements = newElements;
}
```
Це дозволяє зменшити кількість операцій копіювання при розширенні масиву, хоча й може призводити до більшого використання пам'яті порівняно з коефіцієнтом 1.5.

### 5. Чому в Java ArrayList успадковує Collection, а HashMap — ні?

ArrayList є послідовною колекцією елементів, що відповідає концепції Collection. HashMap зберігає пари ключ-значення, що не відповідає концепції Collection. HashMap реалізує інтерфейс Map, який є окремою гілкою в ієрархії колекцій Java.

## LinkedList

### 6. Що як зробити запит на елемент в зв'язному списку, індекс якого більше ніж його розмір?

Буде викинуто виняток `IndexOutOfBoundsException`, оскільки такого елемента не існує.

### 7. Який може бути максимальний розмір LinkedList'у?

Теоретично обмежений лише доступною пам'яттю JVM та максимальним значенням int (2^31-1 = 2,147,483,647 елементів), оскільки size має тип int.

### 8. Які плюси та мінуси у двонаправленого зв'язного списку в порівнянні односпрямованим?

**Плюси**:
- Можливість руху в обох напрямках
- Ефективне видалення з обох кінців
- Швидший доступ до елементів з кінця списку

**Мінуси**:
- Більше використання пам'яті (додаткове посилання на попередній елемент)
- Складніша реалізація
- Більше операцій при вставці/видаленні

**У моїй реалізації MyLinkedList** використовується двонаправлений зв'язний список з вузлами, що містять посилання як на наступний, так і на попередній елемент:
```java
private static class Node<T> {
    T data;
    Node<T> prev;
    Node<T> next;
    
    Node(T data, Node<T> prev, Node<T> next) {
        this.data = data;
        this.prev = prev;
        this.next = next;
    }
}
```
Це дозволяє ефективно реалізувати методи `addFirst()`, `addLast()`, `removeFirst()`, `removeLast()`, а також `lastIndexOf()`, який шукає елементи з кінця списку.

### 9. Як впорядкувати LinkedList? Та навіщо?

Можна використати `Collections.sort()` або власну реалізацію алгоритмів сортування. Впорядкування потрібне для:
- Бінарного пошуку
- Підтримки природного порядку елементів
- Відображення відсортованих даних користувачу

### 10. Яка колекція більше впливає на час збирання сміття?

LinkedList створює більше об'єктів (Node для кожного елемента), що збільшує навантаження на збирач сміття порівняно з ArrayList, який зберігає елементи в масиві.

### 11. Яка колекція ефективніше використовує пам'ять?

Залежить від ситуації:
- ArrayList ефективніший при заповненні близько до capacity, але може витрачати пам'ять на невикористані слоти
- LinkedList використовує додаткову пам'ять на Node об'єкти з посиланнями, але не має невикористаних слотів

## Stack

### 12. Що таке LIFO та FIFO? Як це пов'язано з колекціями цього тижня?

**LIFO** (Last In, First Out) - останній увійшов, перший вийшов - принцип роботи стеку.
**FIFO** (First In, First Out) - перший увійшов, перший вийшов - принцип роботи черги.
Ми реалізували Stack (LIFO) та Queue (FIFO) як окремі колекції.

### 13. На чому краще будувати стек — на масиві, або зв'язковому списку?

На масиві (ArrayList), оскільки для стеку потрібні операції додавання та видалення з кінця, які в ArrayList виконуються за O(1), а доступ до середини колекції не потрібен.

**У моїй реалізації MyStack** використовується саме ArrayList як базова структура даних:
```java
public class MyStack<T> implements Iterable<T> {
    private MyArrayList<T> elements;
    
    public MyStack() {
        elements = new MyArrayList<>();
    }
    
    public void push(T item) {
        elements.add(item);
    }
    
    public T pop() {
        if (isEmpty()) {
            throw new IllegalStateException("Стек порожній");
        }
        T item = elements.get(elements.size() - 1);
        elements.remove(item);
        return item;
    }
    // ...
}
```
Це забезпечує ефективні операції додавання (push) та видалення (pop) елементів з кінця колекції.

### 14. Чи можна використовувати ArrayList замість Stack?

Так, ArrayList можна використовувати як Stack, додаючи/видаляючи елементи з кінця.

**Плюси**:
- Більш гнучкий інтерфейс

**Мінуси**:
- Менш зрозумілий код
- Можливість випадково порушити семантику Stack, використовуючи невідповідні методи

## Queue

### 15. Що таке deque, та як вона відрізняється від arraylist та linkedlist?

Deque (Double-Ended Queue) - двостороння черга, яка дозволяє додавати та видаляти елементи з обох кінців. Відрізняється від ArrayList тим, що оптимізована для роботи з обома кінцями, а від LinkedList тим, що має спеціалізований інтерфейс для таких операцій.

### 16. Чи можна використовувати LinkedList замість Queue?

Так, LinkedList можна використовувати як Queue, додаючи в кінець і видаляючи з початку.

**Плюси**:
- Більш гнучкий інтерфейс

**Мінуси**:
- Менш зрозумілий код
- Можливість випадково порушити семантику Queue, використовуючи невідповідні методи

**У моїй реалізації MyQueue** використовується саме LinkedList як базова структура даних:
```java
public class MyQueue<T> implements Iterable<T> {
    private MyLinkedList<T> elements;
    
    public MyQueue() {
        elements = new MyLinkedList<>();
    }
    
    public void enqueue(T item) {
        elements.add(item);
    }
    
    public T dequeue() {
        if (isEmpty()) {
            throw new IllegalStateException("Черга порожня");
        }
        T item = elements.peek();
        elements.poll();
        return item;
    }
    // ...
}
```
Це забезпечує ефективні операції додавання елементів у кінець (enqueue) та видалення з початку (dequeue), що відповідає принципу FIFO.

## Загальні питання

### 17. Як інтерфейс Iterable пов'язаний з колекціями?

Інтерфейс Iterable є базовим для всіх колекцій в Java. Він дозволяє використовувати цикл for-each (for (T item : collection)) та отримувати ітератор для послідовного доступу до елементів колекції.

**У моїх реалізаціях колекцій** всі класи (MyArrayList, MyLinkedList, MyStack, MyQueue) реалізують інтерфейс Iterable, що дозволяє використовувати їх у циклі for-each. Наприклад, реалізація ітератора для MyArrayList:
```java
private class ArrayListIterator implements Iterator<T> {
    private int currentIndex = 0;
    
    @Override
    public boolean hasNext() {
        return currentIndex < size;
    }
    
    @Override
    public T next() {
        if (!hasNext()) {
            throw new IndexOutOfBoundsException("No more elements");
        }
        return get(currentIndex++);
    }
}
```

### 18. Чи можна працювати з колекцією з декількох потоків одночасно?

Стандартні колекції не є потокобезпечними. При одночасному доступі можуть виникати проблеми з цілісністю даних, race conditions, втрата оновлень.

**Рішення**:
- Використовувати синхронізовані обгортки (Collections.synchronizedList)
- Потокобезпечні колекції (ConcurrentHashMap, CopyOnWriteArrayList)
- Зовнішня синхронізація

### 19. Що набагато краще для роботи в багатопотоковому режимі — ArrayList або LinkedList?

Жоден не є потокобезпечним за замовчуванням. Для багатопотоковості краще використовувати спеціалізовані колекції як CopyOnWriteArrayList або синхронізовані обгортки.

### 20. Чи можна отримати ConcurrentModificationException в однопоточном додатку?

Так, якщо модифікувати колекцію під час ітерації через неї (крім використання Iterator.remove()). Наприклад, при видаленні елементів у циклі for-each.

### 21. Як правильніше видаляти елементи з колекції в процесі проходу по ній в циклі for?

Використовуючи ітератор та його метод remove():
```java
Iterator it = list.iterator();
while(it.hasNext()) {
    if(condition) it.remove();
}
```
Або проходити колекцію у зворотному порядку при використанні індексів.

### 22. Чому цикл for працює тільки з Iterable?

Цикл for-each (for (T item : collection)) вимагає, щоб об'єкт реалізував інтерфейс Iterable, який надає метод iterator() для послідовного доступу до елементів.

### 23. Як цикл for виглядає на рівні байткода Java?

На рівні байткоду for-each перетворюється на виклик iterator(), перевірку hasNext() та виклик next() в циклі while з відповідними інструкціями переходу.

### 24. Які структури даних схожі за рівнем складності на LinkedList та ArrayList?

**ArrayList**:
- Vector
- CopyOnWriteArrayList
- StringBuilder (динамічний масив символів)

**LinkedList**:
- ConcurrentLinkedQueue
- LinkedHashMap/Set (зв'язний список + хеш-таблиця)

### 25. Як влаштований всередині String? Якій структурі даних він подібний всередині?

String в Java реалізований як масив символів (char[] до Java 9, byte[] після). Він подібний до ArrayList, але є незмінним (immutable).